= centro{nbsp}{nbsp}{nbsp}image:https://travis-ci.org/davedoesdev/centro-js.png[Build Status,link=https://travis-ci.org/davedoesdev/centro-js] image:https://coveralls.io/repos/davedoesdev/centro-js/badge.png?branch=master&service=github[Coverage Status,link=https://coveralls.io/r/davedoesdev/centro-js?branch=master] image:https://badge.fury.io/js/centro-js.png[NPM version,link=http://badge.fury.io/js/centro-js]

Centro is a Node.js module for publishing and subscribing to messages over a
network. It includes code for running a server and clients which connect to a
server.

Messages are published to topics which support wildcard matching (single- and
multi-level).

Each message has its own content stream, with full back-pressure support, and
can be delivered to multiple interested clients or to exactly one.

All messages are stored in a directory on the server machine's filesystem so no
external services are required. You can run multiple server instances on the
same directory, for example one per CPU core.

Clients can connect to the server using https://github.com/primus/primus[Primus]
(Websockets), TCP, HTTP or in-memory streams.

The API is described http://rawgit.davedoesdev.com/davedoesdev/centro/master/docs/index.html[here].

== Example

=== Server

Here's a server which listens on all transports.

[source,javascript]
.server.js
----
var centro = require('centro-js');

var config = {
    allowed_algs: ['PS256'], <1>
    transports: [{
        server: 'tcp',
        config: { port: 8800 }
    }, {
        server: 'primus',
        config: { port: 8801 }
    }, {
        server: 'http',
        config: { port: 8802 }
    }, {
        server: 'in-mem',
        authorize_config: { ANONYMOUS_MODE: true } <2>
    }]
};

var server = new centro.CentroServer(config);

server.on('ready', function ()
{
    console.log('READY.');
});
----
<1> <<authz-tokens,Authorization tokens>> signed with these algorithms are accepted.
<2> In-memory transport doesn't require authorization tokens.
<3> Connections may be refused until `ready` is emitted.

This is just an example -- you only need to list transports to which your
applications will connect.

[[authz-tokens]]
=== Authorization tokens

Transports not configured for `ANONYMOUS_MODE` expect clients to present an
authorization token when they connect.

Centro uses https://github.com/davedoesdev/authorize-jwt[authorize-jwt] to
verify tokens. Your tokens must be http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html[JSON Web Tokens]. You should generate a keypair, add the
public key to ``authorize-jwt``'s keystore and sign your tokens with the private
key.

Here's a program which generates a keypair using https://github.com/quartzjer/ursa[ursa], adds the public key to Centro's keystore with the identifier
`http://davedoesdev.com`, and writes the private key to `priv_key.pem`:

[source,javascript]
.add_key.js
----
var uri = 'http://davedoesdev.com', <1>
    authorize_jwt = require('centro-js').authorize_jwt,
    assert = require('assert'),
    path = require('path'),
    fs = require('fs'),
    ursa = require('ursa'),
    priv_key = ursa.generatePrivateKey(2048, 65537), <2>
    pub_key = priv_key.toPublicPem('utf8'); <3>

authorize_jwt(
{
    db_type: 'pouchdb', <4>
    db_for_update: true, <5>
    no_changes: true <6>
}, function (err, authz)
{
    assert.ifError(err);
    authz.keystore.add_pub_key(uri, pub_key, function (err) <7>
    {
        assert.ifError(err);
        fs.writeFile(path.join(__dirname, 'priv_key.pem'), <8>
                     priv_key.toPrivatePem(),
                     assert.ifError);
        authz.keystore.deploy(); <9>
    });
});
----
<1> Unique identifier for the keypair.
<2> Generate the keypair.
<3> Get the public key in PEM form.
<4> You can use `couchdb` but you'll have to set up your own http://couchdb.apache.org/[CouchDB] server.
<5> We're going to update the keystore.
<6> We're not interested in changes to the keystore -- we're just going to update the public key and exit.
<7> Associate the public key with `http://davedoesdev.com`.
<8> The private key is not stored in the keystore but needs to be available when you want to sign authorization tokens. Here we write it to disk but this is just an example -- you probably want a more secure way of storing it.
<9> https://pouchdb.com/[PouchDB]-based keystores update a master database and then replicate changes to reader databases. Here we `deploy()` the master database to let any active reader databases know we're done updating. 

Then you need to make a JWT, using the private key to sign it.

The `iss` claim in the token should be the unique issuer ID associated with
`http://davedoesdev.com` in Centro's keystore. You can use the
https://github.com/davedoesdev/pub-keystore#pubkeystoreprototypeget_pub_key_by_uriuri-cb[`get_pub_key_by_uri`] method to retrieve the issuer ID.
Clients which use tokens with different issuer IDs can't send messages to each
other.

The `access_control` claim in the token should specify to which topics clients
that present this token can publish and subscribe. Topics should be in
amqp format: `.` delimits words, `*` matches exactly one word and `#` matches
zero or more words.

You can use any JWT module to generate your tokens. Here's an example using
https://github.com/davedoesdev/node-jsjws[jsjws]:

[source,javascript]
.make_token.js
----
var uri = 'http://davedoesdev.com',
    authorize_jwt = require('centro-js').authorize_jwt,
    jsjws = require('jsjws'),
    assert = require('assert'),
    path = require('path'),
    fs = require('fs'),
    ursa = require('ursa');

fs.readFile(path.join(__dirname, 'priv_key.pem'), function (err, priv_key) <1>
{
    assert.ifError(err);

    var expiry = new Date();
    expiry.setHours(expiry.getHours() + 24); <2>

    authorize_jwt( <3>
    {
        db_type: 'pouchdb',
        deploy_name: 'token',
        no_changes: true,
        silent: true
    }, function (err, authz)
    {
        assert.ifError(err);
        authz.keystore.get_pub_key_by_uri(uri, function (err, pub_key, issuer_id) <4>
        {
            assert.ifError(err);
            assert(pub_key);
            assert(issuer_id);
            console.log(new jsjws.JWT().generateJWTByKey({ alg: 'PS256' },
            {
                iss: issuer_id, <5>
                access_control: { <6>
                    subscribe: { allow: ['#'], disallow: [] },
                    publish: { allow: ['#'], disallow: [] }
                }
            }, expiry, ursa.createPrivateKey(priv_key))); <7>
        });
    });
});
----
<1> Read the private key. This is just an example -- you should have a more secure way of storing private keys.
<2> Set token expiry to 24 hours.
<3> Open the keystore for reading.
<4> Retrieve the issuer ID for `http://davedoesdev.com`.
<5> Use the issuer ID in the token.
<6> Allow clients using this token to subscribe and publish to any topic.
<7> Supply the expiry time and private key for signing.

The token is valid for 24 hours, allows clients which use it to publish and
subscribe to any topic and is written to standard output. The client examples
below expect it in an environment variable called `CENTRO_TOKEN` so you might
do something like this to set it:

[source,bash]
----
export CENTRO_TOKEN=$(node make_token.js)
----

=== Node clients

==== TCP

Subscribe to a topic given on the command line and display the topic and content
of each message received:

[source,javascript]
.subscribe_tcp.js
----
var centro = require('centro-js'),
    net = require('net'),
    assert = require('assert');

net.createConnection(8800, function () <1>
{
    centro.stream_auth(this, <2>
    {
        token: process.env.CENTRO_TOKEN <3>
    }).on('ready', function ()
    {
        this.subscribe(process.argv[2], function (s, info) <4>
        {
            console.log('topic:', info.topic); <5>
            s.pipe(process.stdout); <6>
        }, assert.ifError);
    });
});
----
<1> Open a TCP connection to the server on port 8800.
<2> The TCP transport expects the token on the connection stream.
<3> Read the token from the environment.
<4> Subscribe to the topic given on the comment line.
<5> Display the message's topic
<6> Pipe the message's content stream to standard output.

Publish a message, topic given on the command line and content read from
standard input:

[source,javascript]
.publish_tcp.js
----
var centro = require('centro-js'),
    net = require('net'),
    assert = require('assert');

net.createConnection(8800, function ()
{
    var conn = this;

    centro.stream_auth(conn,
    {
        token: process.env.CENTRO_TOKEN
    }).on('ready', function ()
    {
        process.stdin.pipe(this.publish(process.argv[2], function (err) <1><2>
        {
            assert.ifError(err);
            conn.end(); <3>
        }));
    });
});
----
<1> Publish the message to the topic given on the command line.
<2> Pipe standard input to the message's content stream.
<3> Close the TCP connection, which will also cause the process to exit.

Here's a sample run:

[cols="a,a",frame="none",grid="none"]
|===

|[source,bash]
----
$ node subscribe_tcp.js foo
topic: foo
hello
----

|[source,bash]
----
$ echo hello \| node publish_tcp.js foo
----
|===

==== Primus

Here are similar clients which use the Primus transport.

[source,javascript]
.subscribe_primus.js
----
var centro = require('centro-js'),
    assert = require('assert'),
    Primus = require('primus'),
    Socket = Primus.createSocket(
    {
        pathname: '/centro/v' + centro.version + '/primus' <1>
    }),
    PrimusDuplex = require('primus-backpressure').PrimusDuplex; <2>

centro.separate_auth( <3>
{
    token: process.env.CENTRO_TOKEN
}, function (err, userpass, make_client)
{
    assert.ifError(err);

    var socket = new Socket('http://' + userpass + '@localhost:8801', <4>
                            { strategy: false }), <5>
        duplex = new PrimusDuplex(socket);

    make_client(duplex).on('ready', function () <6>
    {
        this.subscribe(process.argv[2], function (s, info)
        {
            console.log('topic:', info.topic);
            s.pipe(process.stdout);
        }, assert.ifError);
    });
});
----
<1> The Primus transport uses a versioned path.
<2> The Primus transport uses https://github.com/davedoesdev/primus-backpressure[primus-backpressure].
<3> The Primus transport expects the token to be supplied in the HTTP request authorization, before the connection stream is established.
<4> Open a connection to the server.
<5> You should disable Primus's auto-reconnect feature because it doesn't work with Centro. Centro's connections are stateful (they have shared state between the client and server). The server deletes its state immediately upon disconnect. If you need auto-reconnect you should implement it in your application.
<6> Establish a connection stream to the server.

[source,javascript]
.publish_primus.js
----
var centro = require('centro-js'),
    assert = require('assert'),
    Primus = require('primus'),
    Socket = Primus.createSocket(
    {
        pathname: '/centro/v' + centro.version + '/primus'
    }),
    PrimusDuplex = require('primus-backpressure').PrimusDuplex;

centro.separate_auth(
{
    token: process.env.CENTRO_TOKEN
}, function (err, userpass, make_client)
{
    assert.ifError(err);

    var socket = new Socket('http://' + userpass + '@localhost:8801',
                            { strategy: false }),
        duplex = new PrimusDuplex(socket);

    make_client(duplex).on('ready', function ()
    {
        process.stdin.pipe(this.publish(process.argv[2], function (err)
        {
            assert.ifError(err);
            duplex.end();
        }));
    });
});
----

=== Web clients

==== Primus

==== HTTP

=== In-memory client

The `in-mem` transport lets you connect from the server process itself without
the overhead of a TCP connection. For example, to display every message
published on every transport you could add the following to `server.js`:

[source,javascript]
.server.js
----
var assert = require('assert');

server.on('ready', function ()
{
    this.transport_ops['in-mem'].connect(function (err, stream)
    {
        assert.ifError(err);

        centro.stream_auth(stream).subscribe('#', function (s, info)
        {
            console.log('topic:', info.topic);
            s.pipe(process.stdout);
        }, assert.ifError);
    });
});
----


////
Will use:

  - [mqlobber](https://github.com/davedoesdev/mqlobber)
  - [mqlobber-access-control](https://github.com/davedoesdev/mqlobber-access-control)
  - [qlobber-fsq](https://github.com/davedoesdev/qlobber-fsq)
  - [authorize-jwt](https://github.com/davedoesdev/authorize-jwt)
  - [Primus](https://github.com/primus/primus)
  - [primus-backpressure](https://github.com/davedoesdev/primus-backpressure)
  - Timeout on messages to prevent consumers keeping files open
  - [fastest-writable](https://github.com/davedoesdev/fastest-writable) to prevent slow consumers timing out a message
  - [simple-crypt](https://github.com/davedoesdev/simple-crypt) with stream API addition for optional data encryption

This is a work-in-progress!
////
